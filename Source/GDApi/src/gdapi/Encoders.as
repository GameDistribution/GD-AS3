package gdapi{	import flash.display.BitmapData;	import flash.utils.ByteArray;		internal final class Encoders	{			// ----------------------------------------------------------------------------		// Base64 encoding		// ----------------------------------------------------------------------------		// http://dynamicflash.com/goodies/base64/		//		// Copyright (c) 2006 Steve Webster		// Permission is hereby granted, free of charge, to any person obtaining a copy of		// this software and associated documentation files (the "Software"), to deal in		// the Software without restriction, including without limitation the rights to		// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of		// the Software, and to permit persons to whom the Software is furnished to do so,		// subject to the following conditions: 		// The above copyright notice and this permission notice shall be included in all		// copies or substantial portions of the Software.		private static const BASE64_CHARS:String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";		internal static function Base64(data:ByteArray):String 		{			var output:String = "";			var dataBuffer:Array;			var outputBuffer:Array = new Array(4);			var i:uint;			var j:uint;			var k:uint;						data.position = 0;						while (data.bytesAvailable > 0) 			{				dataBuffer = new Array();								for(i=0; i<3 && data.bytesAvailable>0; i++) 					dataBuffer[i] = data.readUnsignedByte();								outputBuffer[0] = (dataBuffer[0] & 0xfc) >> 2;				outputBuffer[1] = ((dataBuffer[0] & 0x03) << 4) | ((dataBuffer[1]) >> 4);				outputBuffer[2] = ((dataBuffer[1] & 0x0f) << 2) | ((dataBuffer[2]) >> 6);				outputBuffer[3] = dataBuffer[2] & 0x3f;								for(j=dataBuffer.length; j<3; j++)					outputBuffer[j + 1] = 64;								for (k = 0; k<outputBuffer.length; k++)					output += BASE64_CHARS.charAt(outputBuffer[k]);			}						return output;		}				// BASE 64 decoding via http://www.foxarc.com/blog/article/60.htm		private static  const decodeChars:Array =            [-1, -1, -1, -1, -1, -1, -1, -1,           -1, -1, -1, -1, -1, -1, -1, -1,           -1, -1, -1, -1, -1, -1, -1, -1,           -1, -1, -1, -1, -1, -1, -1, -1,           -1, -1, -1, -1, -1, -1, -1, -1,           -1, -1, -1, 62, -1, -1, -1, 63,           52, 53, 54, 55, 56, 57, 58, 59,           60, 61, -1, -1, -1, -1, -1, -1,           -1,  0,  1,  2,  3,  4,  5,  6,            7,  8,  9, 10, 11, 12, 13, 14,           15, 16, 17, 18, 19, 20, 21, 22,           23, 24, 25, -1, -1, -1, -1, -1,           -1, 26, 27, 28, 29, 30, 31, 32,           33, 34, 35, 36, 37, 38, 39, 40,           41, 42, 43, 44, 45, 46, 47, 48,           49, 50, 51, -1, -1, -1, -1, -1];   				internal static function Base64Decode(str:String):ByteArray 		{               var c1:int;               var c2:int;   			            var c3:int;               var c4:int;               var i:int;               var len:int;               var out:ByteArray;               len = str.length;               i = 0;               out = new ByteArray();               while (i < len) {                   // c1                   do {                       c1 = decodeChars[str.charCodeAt(i++) & 0xff];                   } while (i < len && c1 == -1);                   if (c1 == -1) {                       break;                   }                   // c2                       do {                       c2 = decodeChars[str.charCodeAt(i++) & 0xff];                   } while (i < len && c2 == -1);                   if (c2 == -1) {                       break;                   }                   out.writeByte((c1 << 2) | ((c2 & 0x30) >> 4));                   // c3                   do {                       c3 = str.charCodeAt(i++) & 0xff;                       if (c3 == 61) {                           return out;                       }                       c3 = decodeChars[c3];                   } while (i < len && c3 == -1);                   if (c3 == -1) {                       break;                   }                   out.writeByte(((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2));                   // c4                   do {                       c4 = str.charCodeAt(i++) & 0xff;                       if (c4 == 61) {                           return out;                       }                       c4 = decodeChars[c4];                   } while (i < len && c4 == -1);                   if (c4 == -1) {                       break;                   }                   out.writeByte(((c3 & 0x03) << 6) | c4);               }               return out;           }  				// ----------------------------------------------------------------------------		// PNG encoding		// ----------------------------------------------------------------------------		// http://code.google.com/p/as3corelib/source/browse/trunk/src/com/adobe/images/PNGEncoder.as		// 		// Copyright (c) 2008, Adobe Systems Incorporated  		// All rights reserved.			   internal static function PNG(img:BitmapData):ByteArray 	   {			// Create output byte array			var png:ByteArray = new ByteArray();			png.writeUnsignedInt(0x89504e47);			png.writeUnsignedInt(0x0D0A1A0A);			var IHDR:ByteArray = new ByteArray();			IHDR.writeInt(img.width);			IHDR.writeInt(img.height);			IHDR.writeUnsignedInt(0x08060000); // 32bit RGBA			IHDR.writeByte(0);			writeChunk(png,0x49484452,IHDR);			var IDAT:ByteArray= new ByteArray();			var p:uint;			var j:int;						for(var i:int=0;i < img.height;i++) 			{				// no filter				IDAT.writeByte(0);				if (!img.transparent)				{					for(j=0;j < img.width;j++) 					{						p = img.getPixel(j,i);						IDAT.writeUnsignedInt(uint(((p&0xFFFFFF) << 8) | 0xFF));					}				} 				else 				{					for(j=0;j < img.width;j++) 					{						p = img.getPixel32(j,i);						IDAT.writeUnsignedInt(uint(((p&0xFFFFFF) << 8) |	(p>>>24)));					}				}			}						IDAT.compress();			writeChunk(png,0x49444154,IDAT);			writeChunk(png,0x49454E44, null);			return png;		}			private static var crcTable:Array;		private static var crcTableComputed:Boolean = false;			private static function writeChunk(png:ByteArray, type:uint, data:ByteArray):void 		{			if(!crcTableComputed) 			{				crcTableComputed = true;				crcTable = [];				var c:uint;								for(var n:uint = 0; n < 256; n++) 				{					c = n;										for(var k:uint = 0; k < 8; k++) 					{						if (c & 1) 						{							c = uint(uint(0xedb88320) ^ uint(c >>> 1));						} 						else 						{							c = uint(c >>> 1);						}					}					crcTable[n] = c;				}			}						var len:uint = 0;			if(data != null) 			{				len = data.length;			}			png.writeUnsignedInt(len);						var p:uint = png.position;			png.writeUnsignedInt(type);						if(data != null) 			{				png.writeBytes(data);			}						var e:uint = png.position;			png.position = p;			c = 0xffffffff;						for(var i:int=0; i<(e-p); i++) 			{				c = uint(crcTable[(c ^ png.readUnsignedByte()) & uint(0xff)] ^ uint(c >>> 8));			}						c = uint(c^uint(0xffffffff));			png.position = e;			png.writeUnsignedInt(c);		}		/**		 * The MD5 Message-Digest Algorithm		 *		 * Implementation based on algorithm description at 		 * http://www.faqs.org/rfcs/rfc1321.html		 */		public static var digest:ByteArray;		/**		 * Performs the MD5 hash algorithm on a string.		 *		 * @param s The string to hash		 * @return A string containing the hash value of s		 * @langversion ActionScript 3.0		 * @playerversion Flash 8.5		 * @tiptext		 */		private static var hex_chr:String = "0123456789abcdef";				public static function MD5(s:String) :String{			//Convert to byteArray and send through hashBinary function			// so as to only have complex code in one location			var ba:ByteArray = new ByteArray();			ba.writeUTFBytes(s);				return MD5Binary(ba);		}				public static function MD5Bytes(s:ByteArray) :String{				return MD5Binary(s);		}				/**		 * Performs the MD5 hash algorithm on a ByteArray.		 *		 * @param s The string to hash		 * @return A string containing the hash value of s		 * @langversion ActionScript 3.0		 * @playerversion Flash 8.5		 * @tiptext		 */	 		public static function MD5Binary( s:ByteArray ):String {			// initialize the md buffers			var a:int = 1732584193;			var b:int = -271733879;			var c:int = -1732584194;			var d:int = 271733878;						// variables to store previous values			var aa:int;			var bb:int;			var cc:int;			var dd:int;						// create the blocks from the string and			// save the length as a local var to reduce			// lookup in the loop below			var x:Array = createBlocks( s );			var len:int = x.length;						// loop over all of the blocks			for ( var i:int = 0; i < len; i += 16) {				// save previous values				aa = a;				bb = b;				cc = c;				dd = d;												// Round 1				a = ff( a, b, c, d, x[int(i+ 0)],  7, -680876936 ); 	// 1				d = ff( d, a, b, c, x[int(i+ 1)], 12, -389564586 );	// 2				c = ff( c, d, a, b, x[int(i+ 2)], 17, 606105819 ); 	// 3				b = ff( b, c, d, a, x[int(i+ 3)], 22, -1044525330 );	// 4				a = ff( a, b, c, d, x[int(i+ 4)],  7, -176418897 ); 	// 5				d = ff( d, a, b, c, x[int(i+ 5)], 12, 1200080426 ); 	// 6				c = ff( c, d, a, b, x[int(i+ 6)], 17, -1473231341 );	// 7				b = ff( b, c, d, a, x[int(i+ 7)], 22, -45705983 ); 	// 8				a = ff( a, b, c, d, x[int(i+ 8)],  7, 1770035416 ); 	// 9				d = ff( d, a, b, c, x[int(i+ 9)], 12, -1958414417 );	// 10				c = ff( c, d, a, b, x[int(i+10)], 17, -42063 ); 		// 11				b = ff( b, c, d, a, x[int(i+11)], 22, -1990404162 );	// 12				a = ff( a, b, c, d, x[int(i+12)],  7, 1804603682 ); 	// 13				d = ff( d, a, b, c, x[int(i+13)], 12, -40341101 ); 	// 14				c = ff( c, d, a, b, x[int(i+14)], 17, -1502002290 );	// 15				b = ff( b, c, d, a, x[int(i+15)], 22, 1236535329 ); 	// 16								// Round 2				a = gg( a, b, c, d, x[int(i+ 1)],  5, -165796510 ); 	// 17				d = gg( d, a, b, c, x[int(i+ 6)],  9, -1069501632 );	// 18				c = gg( c, d, a, b, x[int(i+11)], 14, 643717713 ); 	// 19				b = gg( b, c, d, a, x[int(i+ 0)], 20, -373897302 ); 	// 20				a = gg( a, b, c, d, x[int(i+ 5)],  5, -701558691 ); 	// 21				d = gg( d, a, b, c, x[int(i+10)],  9, 38016083 ); 	// 22				c = gg( c, d, a, b, x[int(i+15)], 14, -660478335 ); 	// 23				b = gg( b, c, d, a, x[int(i+ 4)], 20, -405537848 ); 	// 24				a = gg( a, b, c, d, x[int(i+ 9)],  5, 568446438 ); 	// 25				d = gg( d, a, b, c, x[int(i+14)],  9, -1019803690 );	// 26				c = gg( c, d, a, b, x[int(i+ 3)], 14, -187363961 ); 	// 27				b = gg( b, c, d, a, x[int(i+ 8)], 20, 1163531501 ); 	// 28				a = gg( a, b, c, d, x[int(i+13)],  5, -1444681467 );	// 29				d = gg( d, a, b, c, x[int(i+ 2)],  9, -51403784 ); 	// 30				c = gg( c, d, a, b, x[int(i+ 7)], 14, 1735328473 ); 	// 31				b = gg( b, c, d, a, x[int(i+12)], 20, -1926607734 );	// 32								// Round 3				a = hh( a, b, c, d, x[int(i+ 5)],  4, -378558 ); 	// 33				d = hh( d, a, b, c, x[int(i+ 8)], 11, -2022574463 );	// 34				c = hh( c, d, a, b, x[int(i+11)], 16, 1839030562 ); 	// 35				b = hh( b, c, d, a, x[int(i+14)], 23, -35309556 ); 	// 36				a = hh( a, b, c, d, x[int(i+ 1)],  4, -1530992060 );	// 37				d = hh( d, a, b, c, x[int(i+ 4)], 11, 1272893353 ); 	// 38				c = hh( c, d, a, b, x[int(i+ 7)], 16, -155497632 ); 	// 39				b = hh( b, c, d, a, x[int(i+10)], 23, -1094730640 );	// 40				a = hh( a, b, c, d, x[int(i+13)],  4, 681279174 ); 	// 41				d = hh( d, a, b, c, x[int(i+ 0)], 11, -358537222 ); 	// 42				c = hh( c, d, a, b, x[int(i+ 3)], 16, -722521979 ); 	// 43				b = hh( b, c, d, a, x[int(i+ 6)], 23, 76029189 ); 	// 44				a = hh( a, b, c, d, x[int(i+ 9)],  4, -640364487 ); 	// 45				d = hh( d, a, b, c, x[int(i+12)], 11, -421815835 ); 	// 46				c = hh( c, d, a, b, x[int(i+15)], 16, 530742520 ); 	// 47				b = hh( b, c, d, a, x[int(i+ 2)], 23, -995338651 ); 	// 48								// Round 4				a = ii( a, b, c, d, x[int(i+ 0)],  6, -198630844 ); 	// 49				d = ii( d, a, b, c, x[int(i+ 7)], 10, 1126891415 ); 	// 50				c = ii( c, d, a, b, x[int(i+14)], 15, -1416354905 );	// 51				b = ii( b, c, d, a, x[int(i+ 5)], 21, -57434055 ); 	// 52				a = ii( a, b, c, d, x[int(i+12)],  6, 1700485571 ); 	// 53				d = ii( d, a, b, c, x[int(i+ 3)], 10, -1894986606 );	// 54				c = ii( c, d, a, b, x[int(i+10)], 15, -1051523 ); 	// 55				b = ii( b, c, d, a, x[int(i+ 1)], 21, -2054922799 );	// 56				a = ii( a, b, c, d, x[int(i+ 8)],  6, 1873313359 ); 	// 57				d = ii( d, a, b, c, x[int(i+15)], 10, -30611744 ); 	// 58				c = ii( c, d, a, b, x[int(i+ 6)], 15, -1560198380 );	// 59				b = ii( b, c, d, a, x[int(i+13)], 21, 1309151649 ); 	// 60				a = ii( a, b, c, d, x[int(i+ 4)],  6, -145523070 ); 	// 61				d = ii( d, a, b, c, x[int(i+11)], 10, -1120210379 );	// 62				c = ii( c, d, a, b, x[int(i+ 2)], 15, 718787259 ); 	// 63				b = ii( b, c, d, a, x[int(i+ 9)], 21, -343485551 ); 	// 64								a += aa;				b += bb;				c += cc;				d += dd;			}			digest = new ByteArray()			digest.writeInt(a);			digest.writeInt(b);			digest.writeInt(c);			digest.writeInt(d);			digest.position = 0;			// Finish up by concatening the buffers with their hex output			return rhex( a ) + rhex( b ) + rhex( c ) + rhex( d );		}				private static function rhex(num:Number):String		{			var str:String = "";			var j:int;						for(j=0; j<=3; j++)				str += hex_chr.charAt((num >> (j * 8 + 4)) & 0x0F) + hex_chr.charAt((num >> (j * 8)) & 0x0F);						return str;		}				private static function rol(num:Number, cnt:Number):Number		{			return (num << cnt) | (num >>> (32 - cnt));		}				/**		 * Auxiliary function f as defined in RFC		 */		private static function f( x:int, y:int, z:int ):int {			return ( x & y ) | ( (~x) & z );		}				/**		 * Auxiliary function g as defined in RFC		 */		private static function g( x:int, y:int, z:int ):int {			return ( x & z ) | ( y & (~z) );		}				/**		 * Auxiliary function h as defined in RFC		 */		private static function h( x:int, y:int, z:int ):int {			return x ^ y ^ z;		}				/**		 * Auxiliary function i as defined in RFC		 */		private static function i( x:int, y:int, z:int ):int {			return y ^ ( x | (~z) );		}				/**		 * A generic transformation function.  The logic of ff, gg, hh, and		 * ii are all the same, minus the function used, so pull that logic		 * out and simplify the method bodies for the transoformation functions.		 */		private static function transform( func:Function, a:int, b:int, c:int, d:int, x:int, s:int, t:int):int {			var tmp:int = a + int( func( b, c, d ) ) + x + t;			return rol( tmp, s ) +  b;		}				/**		 * ff transformation function		 */		private static function ff ( a:int, b:int, c:int, d:int, x:int, s:int, t:int ):int {			return transform( f, a, b, c, d, x, s, t );		}				/**		 * gg transformation function		 */		private static function gg ( a:int, b:int, c:int, d:int, x:int, s:int, t:int ):int {			return transform( g, a, b, c, d, x, s, t );		}				/**		 * hh transformation function		 */		private static function hh ( a:int, b:int, c:int, d:int, x:int, s:int, t:int ):int {			return transform( h, a, b, c, d, x, s, t );		}				/**		 * ii transformation function		 */		private static function ii ( a:int, b:int, c:int, d:int, x:int, s:int, t:int ):int {			return transform( i, a, b, c, d, x, s, t );		}				/**		 * Converts a string to a sequence of 16-word blocks		 * that we'll do the processing on.  Appends padding		 * and length in the process.		 *		 * @param s The string to split into blocks		 * @return An array containing the blocks that s was		 *			split into.		 */		private static function createBlocks( s:ByteArray ):Array {			var blocks:Array = new Array();			var len:int = s.length * 8;			var mask:int = 0xFF; // ignore hi byte of characters > 0xFF			for( var i:int = 0; i < len; i += 8 ) {				blocks[ int(i >> 5) ] |= ( s[ i / 8 ] & mask ) << ( i % 32 );			}						// append padding and length			blocks[ int(len >> 5) ] |= 0x80 << ( len % 32 );			blocks[ int(( ( ( len + 64 ) >>> 9 ) << 4 ) + 14) ] = len;			return blocks;		}			}	}